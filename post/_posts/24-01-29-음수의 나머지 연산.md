---
layout: post
date: 2024-01-29 21:08
tags:
  - 프로그래밍
---
음수에 대한 나머지 연산은 통용되는 정의가 없으나[^1] 프로그래밍에선 종종 쓰인다. 때문에 프로그래밍 언어마다 그 정의가 조금씩 다르다. 

[^1]: 대수학에선 제수는 양의 정수, 피제수는 음수를 포함한 정수일 때 나머지 연산이 정의되며, 그 결과는 항상 양수라고 한다.

대부분 프로그래밍 언어에서 나머지 연산은 다음과 같이 정의한다.
```
(a / b) * b + a % b == a
// 이때 a, b는 정수이며 a != 0, b != 0 이다.
```
여기서 `a / b`는 정수의 나눗셈이기 때문에 소숫점 아래 숫자를 버리게 된다.

이때 `a / b`가 음수라면 이를 처리하는 방식이 2갈래로 나뉜다.
- 나눗셈 결과를 0에 가깝게 절삭 (C, Cpp, JavaScript, Java)
- 나눗셈 결과를 음의 방향으로 절삭 (Python, Ruby, Perl, WolframAlpha)
- ~~나눗셈 결과를 양의 방향으로 절삭~~ (양수 나눗셈도 ceil처럼 처리해서 잘 사용하지 않음)

문제는 이 방식마다 나머지 연산의 결과가 달라질 수 있다. 아래는 `a = -3, b = 2`일 때,  2가지 방법으로 나머지 연산이 이루어지는 과정이다.
- `-3 / 2 => -1` 이라면: `-1 * 2 + (-3 % 2) == -3` 이므로 `-3 % 2 == -1` 이다.
- `-3 / 2 => -2` 이라면: `-2 * 2 + (-3 % 2) == -3` 이므로 `-3 % 2 == 1` 이다.

참고로 피연산자의 부호가 바뀌면 결과의 부호도 바뀐다. 아래는 `a = 3, b = -2`에서의 예시이다.
- `3 / -2 => -1` 이라면: `-1 * -2 + (3 % -2) == 3` 이므로 `(3 % -2) == 1`
- `3 / -2 => -2` 이라면: `-2 * -2 + (3 % -2) == 3` 이므로 `(3 % -2) == -1`

결과만 보면 첫번째 방식은 왼쪽 피연산자의 부호를 따르게 되고, 두번째 방식은 오른쪽 피연산자의 부호를 따르게 된다.

## 더 많은 예시

`a = 5, b = -3`
- `5 / -3 => -1` 이라면: `-1 * -3 + (5 % -3) == 5` 이므로 `(5 % -3) == 2`
- `5 / -3 => -2` 이라면: `-2 * -3 + (5 % -3) == 5` 이므로 `(5 % -3) == -1`

`a = -5, b = 3`
- `-5 / 3 => -1` 이라면: `-1 * 3 + (-5 % 3) == -5` 이므로 `(-5 % 3) == -2`
- `-5 / 3 => -2` 이라면: `-2 * 3 + (-5 % 3) == -5` 이므로 `(-5 % 3) == 1`


# 대처법

특히 배열과 함께 쓰다보면 음수 인덱싱이 발생하며 문제가 생기게 된다. 이럴 땐 항상 양수가 되게 하자.
```
((n % m) + m) % m
```

****
# 출처
- [velog 김진용](https://velog.io/@jinyong97/JavaScript-mod-%EC%97%B0%EC%82%B0)
- [KLDP](https://kldp.org/node/55978)
- [John Grip](https://johngrib.github.io/wiki/java/remainder-operator/)